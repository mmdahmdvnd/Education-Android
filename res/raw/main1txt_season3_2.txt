import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Scanner;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.provider.MediaStore.Files;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.ListActivity;
import android.content.DialogInterface;
import android.content.Intent;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

//کلاس Main از ListActivity مشتق میشود که در اینصورت اکتیویتی Main منحصرا یک لیست را نشان میدهد :
public class Main extends ListActivity {

تعریف یک آرایه لیست :
	private ArrayList<String> mylist;

	private String address;
	private int swp=0;
	private String namep="";
	private String addressp="";
	
	private TextView txt1;
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        
        txt1=(TextView)findViewById(R.id.cb);

//فراخوانی تابع refresh که لیست را از نو لود میکند و در اینجا فایلهای درون حافظه ی دستگاه را در لیست نشان میدهد : refresh(Environment.getExternalStorageDirectory().toString());
                  
        ListView lv = getListView();
        lv.setOnItemLongClickListener(new OnItemLongClickListener() {
            public boolean onItemLongClick(AdapterView<?> arg0, View arg1,int row, long arg3) {

            	// your code
            	return true;
            }
        });
      
       
    }

//تابع refresh چندین جای برنامه فراخوانی میشود که هر بار لیست را برای مسیر path که در آن مسیر هستیم ، لود میکند :
    private void refresh(String path){

    	mylist=new ArrayList<String>();
    	address=path;
        File myfile=new File(path);
        File listfile[]=myfile.listFiles();
        
        for(int i=0;i<listfile.length;i++){      	
        	mylist.add(listfile[i].getName());
        }      
        txt1.setText(address);
        setListAdapter(new ArrayAdapter<String>(this,android.R.layout.simple_expandable_list_item_1,mylist));
    }

//با کلیک کردن هر سطر از لیست یک دیالوگ باز میشود که در آن عمل کپی ، کات و... انجام میشود :
    @Override
    protected void onListItemClick(ListView l, View v, final int position, long id) {

    	super.onListItemClick(l, v, position, id);
    		
    	 AlertDialog.Builder builder = new AlertDialog.Builder(this);
         LayoutInflater inflater = this.getLayoutInflater();
         View row = inflater.inflate(R.layout.dialog, null);
         builder.setView(row);

 		Button open = (Button)row.findViewById(R.id.open);
 		Button copy = (Button)row.findViewById(R.id.copy);
 		Button cut = (Button)row.findViewById(R.id.cut);
	Button paste = (Button)row.findViewById(R.id.paste);
 		Button delete = (Button)row.findViewById(R.id.delete);
 		Button rename = (Button)row.findViewById(R.id.rename);
 	
 		
 		final AlertDialog alert11 = builder.create();
        alert11.show();
         

        open.setOnClickListener(new OnClickListener() {
        	public void onClick(View arg0) {	    		
        		File temp=new File(address,mylist.get(position).toString());

 //برای باز کردن هر سطر با کلیک کردن آن ، اگر هر سطر از لیست یک فایل باشد(یعنی پوشه نباشد) یک پیام میگوید که "این فایل است" و اگر فایل نباشد و یک پوشه باشد ، با دستور refresh ، طبق زیر ، آدرس پوشه ی داخلی از این پوشه را به آدرس قبلی اضافه میکند و یک پوشه به داخل میرود و عناصر داخل این پوشه را در لیست لود میکند :         	
            	if(temp.isFile()){       		
          	Toast.makeText(getApplicationContext(), "This is File !!", Toast.LENGTH_LONG).show();         		       		
            	}else{
            		
            		refresh(address+"/"+mylist.get(position).toString());      		
            	}
//آلرت دیالوگ را کنسل میکند :
        		alert11.cancel();
        	}
        });

   

        copy.setOnClickListener(new OnClickListener() {
        	public void onClick(View arg0) {
        		
        		addressp=address;
        		namep=mylist.get(position);
        		swp=1;
        		alert11.cancel();    
        	}
        });

    
    
        cut.setOnClickListener(new OnClickListener() {
        	public void onClick(View arg0) {
        		addressp=address;
        		namep=mylist.get(position);
        		swp=2;
        		alert11.cancel();
        	}
        });

paste.setOnClickListener(new OnClickListener() {
        	public void onClick(View arg0) {
         	if(swp!=0){
    		paste();
    		}else{ 			
    			Toast.makeText(getApplicationContext(), "حافظه کلیپ بورد خالی است", Toast.LENGTH_LONG).show();
    		} 		
        		alert11.cancel();
        	}
        });

 //دکمه ی delete ، فایل موجود در سطر پوزیشن ، در سطر لیست را حذف میکند . تکه کد (position)mylist.get میگوید که به هر پوزیشن از لیست که وارد شویم ، تغییرات را در همانجا اعمال میکنیم :    
        delete.setOnClickListener(new OnClickListener() {
        	public void onClick(View arg0) {
        		File file = new File(address+"/"+mylist.get(position));
        		boolean deleted = file.delete();
        		if(deleted){
        			
        		Toast.makeText(getApplicationContext(), "Delete Completed!!", Toast.LENGTH_LONG).show();	
        		}else{
        			Toast.makeText(getApplicationContext(), "Delete not Completed!!", Toast.LENGTH_LONG).show();	
        		}
        	}
        });

   //دکمه ی rename ، فایل موجود در سطر پوزیشن ، در سطر لیست را به "new name" تغییر نام میدهد :  
        rename.setOnClickListener(new OnClickListener() {
        	public void onClick(View arg0) {
 		
        		File file = new File(address+"/"+mylist.get(position));
        		boolean success = file.renameTo(new File(address+"/"+"newname"));
        		if(success){    			
        			Toast.makeText(getApplicationContext(), "Rename Completed!!", Toast.LENGTH_LONG).show();	
        		}else{
        			Toast.makeText(getApplicationContext(), "Rename not Completed!!", Toast.LENGTH_LONG).show();	
        		} 		
        		refresh(address);
        		alert11.cancel();
        	}
        });
        
           
        
    }
   
 //عمل کپی کردن از مسیر مبدا به مسیر مقصد ، با فراخوانی این تابع صورت میگیرد که در آن از InputStream و OutputStream و یک بافر(که همانند یک ظرف عمل میکند) استفاده شده :
    public void copy(String inpath, String outpath) throws IOException {
       
    	File src=new File(inpath);
		File dst=new File(outpath);
    	
    	InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(dst);
        byte[] buf = new byte[1024];
        int len;
        while ((len = in.read(buf)) > 0) {
            out.write(buf, 0, len);
        }
        in.close();
        out.close();
        Toast.makeText(getApplicationContext(), "Copy Completed!!!", Toast.LENGTH_LONG).show();
    }
    
    
 //تابع paste با مقدار swp برابر 1 یا 2 در کلیدهای copy یا cut ، فراخوانی میشود . با فراخوانی این تابع یک آلرت دیالوگ باز میشود که پیغام های لازم ، در این دیالوگ نشان داده میشوند :
    public void paste(){
    	AlertDialog.Builder builder1 = new AlertDialog.Builder(this);

        if(swp==1){
    	builder1.setMessage("آیا مایل به کپی کردن فایل "+namep+"هستید؟");
        }else{
        	builder1.setMessage("آیا مایل به انتقال فایل "+namep+"هستید؟");
        }
        builder1.setCancelable(true);
        builder1.setPositiveButton("Paste",new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int id) {
            	if(swp==1){         	         		
            		try {
						copy(addressp+"/"+namep,address+"/"+namep);
					} catch (IOException e) {
						e.printStackTrace();
					}       		
            		refresh(address);      		
            	}else{       		
            		File file = new File(addressp+"/"+namep);
            		boolean success = file.renameTo(new File(address+"/"+namep));
            		
            		if(success){          			
             Toast.makeText(getApplicationContext(), "Move Completed!!", Toast.LENGTH_LONG).show();
            		}
            		refresh(address);       		
            	}        	        	
            }
        });
        AlertDialog alert11 = builder1.create();
        alert11.show();
    } 



// با کلیک بر روی کلید "برگشت"(back) در دستگاه ، این تابع توسط متد onBackPressed فراخوانی میشود و با هر بار برگشت ، نام پوشه ای که از آن خارج شده اید ، از انتهای آدرس که در تکست ویوی txt1 نشان داده میشود ، حذف میشود :  
    private void back(){

    	int p=0;
    	for(int i=address.length()-1;i>=0;i--){
    		if(address.charAt(i)=='/'){
    			p=i;
    			break;
    		}
    	}
    	address=address.substring(0, p);
    	refresh(address);	
    }

//با کلیک بر روی دکمه برگشت در دستگاه ، اگر به انتهای پوشه ها رسیده باشیم یعنی به حافظه دستگاه وارد شده باشیم ، متد ()finish  فراخوانی میشود و از برنامه خارج میشویم و اگر هنوز به حافظه دستگاه نرسیده باشیم و داخل یکی از پوشه های درون حافظه دستگاه باشیم ، با فراخوانی تابع ()back ، پوشه و فایلهای درون این پوشه در لیست نشان داده میشود :
    public void onBackPressed() {	if(address.equals(Environment.getExternalStorageDirectory().toString())){
    		finish();
    	}else
    	{
    	back();
    	}
    }
    
    
    
    
}
